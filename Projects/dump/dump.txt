package com.example.dualwrite.tracker;

import com.datastax.oss.driver.api.core.CqlSession;
import com.datastax.oss.driver.api.core.CqlSessionBuilder;
import com.datastax.oss.driver.api.core.config.DriverExecutionProfile;
import com.datastax.oss.driver.api.core.cql.*;
import com.datastax.oss.driver.api.core.metadata.Node;
import com.datastax.oss.driver.api.core.tracker.RequestTracker;
import com.datastax.oss.driver.api.core.session.Request;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.KafkaTemplate;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Single-file implementation of a modern RequestTracker that emits JSON events capturing
 * CQL + column/value/type metadata for writes (including batches).
 */
public class DualWriteRequestTrackerConfig {

    // ==== Data model for event messages ====

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class CassandraRequestEvent {
        private String keyspace;
        private String table;
        private String operation;
        private Instant timestamp;
        private List<StatementPayload> statements;

        @Data
        @AllArgsConstructor
        @NoArgsConstructor
        public static class StatementPayload {
            private String cql;
            private List<ColumnValue> columns;
        }

        @Data
        @AllArgsConstructor
        @NoArgsConstructor
        public static class ColumnValue {
            private String name;
            private Object value;
            private String type;
        }
    }

    // ==== RequestTracker implementation ====

    @Slf4j
    public static class DualWriteRequestTracker implements RequestTracker {
        private final KafkaTemplate<String, String> kafkaTemplate;
        private final String topic;
        private final ObjectMapper mapper = new ObjectMapper();

        public DualWriteRequestTracker(KafkaTemplate<String, String> kafkaTemplate, String topic) {
            this.kafkaTemplate = kafkaTemplate;
            this.topic = topic;
        }

        @Override
        public void onSuccess(Request request,
                              long latencyNanos,
                              DriverExecutionProfile executionProfile,
                              Node node,
                              String requestLogPrefix) {
            try {
                if (request instanceof Statement<?> stmt) {
                    CassandraRequestEvent evt = buildEvent(stmt);
                    if (evt != null) {
                        String json = mapper.writeValueAsString(evt);
                        // Partition key or topic key can be keyspace.table or more refined
                        String key = (evt.getKeyspace() != null ? evt.getKeyspace() : "unknown")
                                + "." + (evt.getTable() != null ? evt.getTable() : "unknown");
                        kafkaTemplate.send(topic, key, json);
                        log.debug("Dual-write event published: {}", json);
                    }
                }
            } catch (Exception e) {
                log.warn("Failed to build or publish dual-write event", e);
            }
        }

        @Override
        public void onError(Request request,
                            Throwable error,
                            long latencyNanos,
                            DriverExecutionProfile executionProfile,
                            Node node,
                            String requestLogPrefix) {
            // We do not emit events for failures; optionally log or metrics
        }

        @Override
        public void onNodeSuccess(Request request, long latencyNanos,
                                  DriverExecutionProfile executionProfile, Node node,
                                  String requestLogPrefix) {
            // optional node-level callback (not used)
        }

        @Override
        public void onNodeError(Request request, Throwable error, long latencyNanos,
                                DriverExecutionProfile executionProfile, Node node,
                                String requestLogPrefix) {
            // optional node-level callback (not used)
        }

        @Override
        public void onSessionReady(CqlSession session) {
            // called when the session is ready (optional)
        }

        /** Build the event representation from a Statement (could be batch or single). */
        private CassandraRequestEvent buildEvent(Statement<?> stmt) {
            if (stmt instanceof BatchStatement batch) {
                List<CassandraRequestEvent.StatementPayload> parts = batch.getStatements().stream()
                        .map(this::buildPayload).filter(Objects::nonNull).collect(Collectors.toList());
                if (parts.isEmpty()) {
                    return null;
                }
                return CassandraRequestEvent.builder()
                        .timestamp(Instant.now())
                        .operation("BATCH")
                        .statements(parts)
                        .build();
            } else {
                CassandraRequestEvent.StatementPayload payload = buildPayload(stmt);
                if (payload == null) {
                    return null;
                }
                String operation = detectOperation(payload.getCql());
                String keyspace = extractKeyspace(payload.getCql());
                String table = extractTable(payload.getCql());
                return CassandraRequestEvent.builder()
                        .timestamp(Instant.now())
                        .operation(operation)
                        .keyspace(keyspace)
                        .table(table)
                        .statements(Collections.singletonList(payload))
                        .build();
            }
        }

        /** Build a payload (CQL + columns) for a single statement (Bound or Simple). */
        private CassandraRequestEvent.StatementPayload buildPayload(Statement<?> stmt) {
            if (stmt instanceof BoundStatement bs) {
                return fromBound(bs);
            } else if (stmt instanceof SimpleStatement ss) {
                return fromSimple(ss);
            } else {
                // not supported type (e.g. a custom Statement subtype) — skip
                return null;
            }
        }

        private CassandraRequestEvent.StatementPayload fromBound(BoundStatement bs) {
            PreparedStatement ps = bs.getPreparedStatement();
            String cql = ps.getQuery();
            List<CassandraRequestEvent.ColumnValue> cols = new ArrayList<>();
            for (ColumnDefinition def : ps.getVariableDefinitions()) {
                String colName = def.getName().asInternal();
                Object val = bs.getObject(def.getName());
                String cqlType = def.getType().asCql(true, true);
                cols.add(new CassandraRequestEvent.ColumnValue(colName, val, cqlType));
            }
            return new CassandraRequestEvent.StatementPayload(cql, cols);
        }

        private CassandraRequestEvent.StatementPayload fromSimple(SimpleStatement ss) {
            String cql = ss.getQuery();
            List<CassandraRequestEvent.ColumnValue> cols = new ArrayList<>();
            // named values, if any
            ss.getNamedValues().forEach((k, v) -> {
                String typeName = v != null ? v.getClass().getSimpleName() : "null";
                cols.add(new CassandraRequestEvent.ColumnValue(k, v, typeName));
            });
            // positional values, if any
            List<Object> pos = ss.getPositionalValues();
            for (int i = 0; i < pos.size(); i++) {
                Object v = pos.get(i);
                String typeName = v != null ? v.getClass().getSimpleName() : "null";
                cols.add(new CassandraRequestEvent.ColumnValue("p" + i, v, typeName));
            }
            return new CassandraRequestEvent.StatementPayload(cql, cols);
        }

        /** Simple heuristic to detect operation from CQL text. */
        private String detectOperation(String cql) {
            String u = cql.trim().toUpperCase(Locale.ROOT);
            if (u.startsWith("INSERT")) return "INSERT";
            if (u.startsWith("UPDATE")) return "UPDATE";
            if (u.startsWith("DELETE")) return "DELETE";
            if (u.startsWith("BATCH")) return "BATCH";
            return "UNKNOWN";
        }

        /** Naive extraction of keyspace from CQL “INSERT INTO ks.tbl …” */
        private String extractKeyspace(String cql) {
            String cu = cql.toUpperCase(Locale.ROOT);
            int idx = cu.indexOf("INTO ");
            if (idx >= 0) {
                String after = cql.substring(idx + 5).trim();
                String first = after.split("[\\s(]+")[0];
                if (first.contains(".")) {
                    return first.split("\\.")[0];
                }
            }
            return null;
        }

        /** Naive extraction of table from CQL “INSERT INTO ks.tbl …” */
        private String extractTable(String cql) {
            String cu = cql.toUpperCase(Locale.ROOT);
            int idx = cu.indexOf("INTO ");
            if (idx >= 0) {
                String after = cql.substring(idx + 5).trim();
                String first = after.split("[\\s(]+")[0];
                if (first.contains(".")) {
                    return first.split("\\.")[1];
                } else {
                    return first;
                }
            }
            return null;
        }
    }

    // ==== Spring configuration to wire into session builder ====

    @Configuration
    public static class TrackerConfig {

        @Bean
        public CqlSession cqlSession(CqlSessionBuilder builder,
                                     KafkaTemplate<String, String> kafkaTemplate) {
            return builder
                    .withRequestTracker(new DualWriteRequestTracker(kafkaTemplate, "cassandra-dualwrite"))
                    .build();
        }
    }
}
